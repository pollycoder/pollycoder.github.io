[
  
  {
    "title": "看到同道中人的 blog 引发的一点小感动",
    "url": "/posts/emo/",
    "categories": "Diary",
    "tags": "Diary",
    "date": "2022-09-22 00:20:30 +0800",
    





    "snippet": "2022.9.22	Thu 	Sunny​        大概是以前见鸡汤见得多了，对鸡汤已经开始免疫甚至是厌恶。因为我总觉得，这些写鸡汤的人只是为了给别人看，他们不理解人们每天的焦虑和痛苦来自何方，就开始肆无忌惮的劝人们放下。所谓“未尝他人苦，莫劝他人善”，这样的鸡汤，喝得越多越让人反胃。我们需要的，是真实的，能够贴近我们的故事的感召。​        人是需要时时回家或者去寻找同道中人的，尤其是在思绪纷乱的时候。我们总说，不要为外界所干扰，要做自己。但是，老祖宗们为了生存，赋予了我们随时感知外界的能力。其实反过来想一想，我们现在许多希望自己改掉的毛病，比如容易被外界干扰，他们不是毛病，只是一种feature，在远古时期可是生存的法宝。然而现在我们进入了所谓的文明时期，即使没有这些特性，我们也可以活着，衣食不愁；又或者，我们因为步入了文明时期，所以我们物竞天择的法则已经变了。不管怎么说，老祖宗留下的feature，在现代已经不适用了。你疯狂改掉刻在你骨子里的东西，有时候本质上是一种内耗。因为，不论你做出什么样的改变，你首先应该想到的应该是“这样的我真的会变好，变幸福吗”；你会被外界干扰，是因为你还不认可现在的自己，不认可自己的选择，你害怕这样会付出什么不可承受的代价，所以你会想到copy其他人的操作。​        然而这样做的代价是什么？别人的人生不可copy，你最终还是会选择和其他人不一样的路。你可以借鉴，但最终抉择的人应该是你，而不是稀里糊涂照做。如果你觉得外界已经干扰了你的生活，那你最需要的就是自我认同。哪里可以为你寻求自我认同？唯有家里，唯有和你持有相同想法的人；家人永远无条件支持你，而同道中人会永远认可你。回到他们身边，离开这个纷繁的外界，人会变得更加理智从容。你会发现现在的你没什么不好，只是你和那原先希望成为的人不太一样，而原先希望成为的人也没有你想的那么的好，或是他吃过的苦你知道你绝对不想去吃，亦或是他成就的事业现在在你看来本就与你想要的事业殊途难归。所以，不要想着能够得到全世界，不要想着自己会做救世主，在博大宇宙面前，你能做自己，已经是大大的伟人了。那些厉害一点的英雄，他们可能在某些时间的节点做了一点点小小的推动，使得某些事情的走向出现了一些变化，但在浩瀚宇宙面前，地球还是那个地球，宇宙更还是那个宇宙。你能找到属于自己的那一片世界，把它经营好，变成你自己的后花园，已经很难了。但至少，家人和友人，甚至只是和你同道的陌生人都能够给你一点助力。他们的鸡汤不一定有多么大补，但一定是暖的，让你全身充满力量；外面的鸡汤再香，它也是冷的，冷鸡汤下肚只会让你腹泻到全身无力。​        废话讲了这许多，终于讲到emo的地方了。为了做自己的blog，我确实面临了很多困难。对前端开发的零基础，让我对GitHub Pages和jekyll的上手变得十分困难，想要在已有模板基础上二次开发更是难度更上一层楼；周围人不理解，觉得我浪费时间，做着无意义的事情，总是不断的消磨我的信心。我甚至也怀疑过做这个blog，亦或是我之前做的许多被周围人认为是无意义的事情，是不是真的没有意义。直到我在尝试二次开发的时候遇到了一个和我用着相同主题的blogger。​         这位Blogger名叫唐悦玮，你在网上也可以搜到他的GitHub pages Blog。他和我一样使用的是chirpy，嗯，至少遇到了一个和我有相同品味的同道中人。他是一位后端开发的工程师，对前端也有一定的了解，看了看他在About里写到的技能树，确实可以算一定程度上的六边形战士，作为一个大二狗我非常佩服，对他给出的能力定位级别机制我也比较认同。可能他自己认为自己还有很大的提升空间，从他没有给自己任何技能点上五星就能看出，但在我看来他已经是我可以学习的神了。他在他的blog里面分享了一些自己的挣扎，比如拖延症，比如三分钟热度，还有自己折腾博客的经历，这中间讲了许多他对生活的看法。原本我只是从他的GitHub模板里学习修改我自己的blog架构，但看了这几篇blog之后，我竟然有种被理解的感觉。这不就是一个普通开发者的日常吗？每天想着自己的创业，想要多点一点技能树，但是又很难克服自己偶尔发作的懒虫，又或者看到别人成功了自己还一事无成，那种挣扎的感觉。但是他现在，根据他的blog推断，已经是一个小有所成的开发团队领头了。有时候你去听那些大佬们在大众面前讲他们的所谓挣扎故事，故事或许是真的，但大众听进去的又有几人呢？毕竟，再怎么真实，也改变不了他是一个公众演讲的事实，总会有这种身份差让人无法完全接受或者认为无法获取太多共鸣。但是blog是每一个开发者自己的空间，里面的记录会不自觉地拉近读者与他的距离。读了他的blog第一次让我真正感受到了一个开发者的真实生活，并在自己的校园开发生活中找到了一点共鸣，突然觉得，哦，我的人生其实不糟哦。​        唐先生还有一句话，很无聊的一句，却让我看到了自己做某些被人认为无意义事情的意义。他提了一句他的blog为什么设置浏览量显示功能，“虽然没几个人看，但功能还是要有的吧。”这句话给了我提醒。之前也有人对我说过，反正我那个blog没几个人看，何必非得花心思搞什么评论和阅读量呢。本身GitHub pages就是生成静态网站的，其实浏览量统计和评论系统因为没有数据库支持只能疯狂借助第三方，在原本主题并未设置的情况下，部署的难度可想而知，而且确实需求导向的话，没几个人看，也没有商业需求，没必要费这个心思。但是你不部署，这blog就是残次品，和真正的blog永远有差距。到了这一步，你还觉得需求才是唯一的导向吗？这是一个人对自己的要求，与别人看不看，与别人觉得你用不用没关系。我只是想做一个真正的blog，就这样。看明白这一层之后，我也对自己收到的外界质疑释怀了许多。我想做，只是因为我想，我喜欢，就够了。而且任何事情，必有它存在的意义。这些看似没用的东西让你成就了一个完整的blog，与此同时你是不是还学会了html, css, yml等等一系列前端的开发手段呢？不要觉得自己学了什么没用的东西，当你要用的时候，你就会知道当初的自己有多么的蠢。因为，你会一定是因为你需要，不管他提供了事业上的助力还是只提供了情绪价值，他、它都有价值。如果有朝一日你不需要了，没关系，你的脑子会帮你忘记它的。​        人最需要的到底还是专注吧，在这个世界太难了。专注的基本前提是自我认同，你认同自己此时此地所做，然后才能不被外界影响。最近迷上了仙剑的《姜氏孤儿》这首配乐，听着让人感动、感慨、同时也让你安静。有时候我也觉得自己和别人很不一样，别人先追剧，配乐只是爱屋及乌；而我不追剧，只追配乐，追完配乐便觉得不必再看剧。因为好剧，它的思想自在配乐中，你只需要知道点点故事梗概就可以抓住这个剧的思想核心了，何必再花那个时间去看情节。听听这首，这首配乐的主人公是个孤儿，临死时发出了即使有义父娘子，自己仍是孤儿的感慨，一念杀生便入了魔。其实我们每个人，从离开父母怀抱的那一刻起，就已经是孤独的旅者了。如果你都不认同自己，你指望谁来认同你？你没尝试过，怎么叫自己真放下？其实仙剑讲的不只是爱的故事，也是道的故事。得道是放下，不是让你一开始就无欲无无求，最终的结果是让你把心思放在天下苍生，不是四大皆空。你要放下的，是你一己私利，是一己身外之物，一切扰乱你心智的事物，无论财富、爱情还是执念。当你心无杂念去做自己，对自己问心无愧之后，你就得道了。"
  },
  
  {
    "title": "Binary Search Tree Python",
    "url": "/posts/Binary-Search-Tree-Python/",
    "categories": "TechNotes, Advanced Python",
    "tags": "DSA",
    "date": "2022-09-14 18:52:30 +0800",
    





    "snippet": "Original ProblemGiven a number list, you can confirm a binary search tree. Now given two specified elements, you have to find the lowest common ancestor. My SolutionSource code is listed below:#!/usr/bin/env python3# Minimum common ancestors of binary seaarch tree# Special acknowledgement for Bingchuan Wei.# After discussed this practice with him, I learned basic binary search tree operation# by myself and succeeded to give an easier solution thanks to his help.# Nodes of a binary treeclass TreeNode:    def __init__(self, val) -&amp;gt; None:        self.val = val        self.left = None        self.right = None    def insert(self, val):        if val &amp;lt; self.val:            if self.left is None:                self.left = TreeNode(val)            else:                self.left.insert(val)        elif val &amp;gt; self.val:            if self.right is None:                self.right = TreeNode(val)            else:                self.right.insert(val)        else:            self.right.insert(val)# A binary search treeclass BSTree:    def __init__(self) -&amp;gt; None:        self.root = None    def construct(self, input_list):        for node_val in input_list:            if self.root is None:                self.root = TreeNode(node_val)            else:                self.root.insert(node_val)# Solution partdef solution(root: &#39;TreeNode&#39;, treenode1: &#39;TreeNode&#39;, treenode2: &#39;TreeNode&#39;):    while root:        if treenode1.val &amp;lt; root.val and treenode2.val &amp;lt; root.val:            root = root.left            continue        elif treenode1.val &amp;gt; root.val and treenode2.val &amp;gt; root.val:            root = root.right        else:            return rootif __name__ == &#39;__main__&#39;:    N, M = input().split()    input_list = list(map(int, input().split()))    tree = BSTree()    tree.construct(input_list)    output_list = []    for i in range(0, int(M)):        val1, val2 = input().split()        node1 = TreeNode(int(val1))        node2 = TreeNode(int(val2))        lowest_ance = solution(tree.root, node1, node2)        output_list.append(lowest_ance.val)    for result in output_list:        print(result)From the source code, you can already infer that my solution is totally based on binary tree operations.  My idea:To solve this problem, binary search tree situation is much easier, for in a binary search tree, it is required that left child node value be smaller than parent node while right child node be larger than parent node. Therefore, if a node is smaller than root node, it should be on the left branch, or else it should be on the right branch. In this problem I tried post-order traversal, which means visit sub-branches first. But this is a little bit tricky, if you try in this way, you will lose the advantage of binary search tree, because you need to use original binary tree traversal. Therefore here we use pre-order traversal, which means we visit root node first."
  },
  
  {
    "title": "Bugs I Encountered (Week 1)",
    "url": "/posts/Bugs-I-Encountered-(Week-1)/",
    "categories": "TechNotes, Advanced Programming",
    "tags": "debug",
    "date": "2022-09-14 18:52:30 +0800",
    





    "snippet": "  Four steps when you build and run your code:      Pre-processing    Compiling    Assembling    LinkingMostly bugs may happen in step 2 and 4.  Why Mac treat warning as ERROR when compiling ?When I did Week 1 homework, there was a bug that only Mac users met.Source code:switch (type) {    case kNoCompression:      block_contents = raw;      break;    default:      assert(false);      break;  }Normally, this code may cause a warning:warning: enumeration value &#39;kSnappyCompression&#39; not handled in switch [-Wswitch]However, when I tested on Mac, it caused an error:error: enumeration value &#39;kSnappyCompression&#39; not handled in switch [-Werror,-Wswitch]Everything went right when I tested on Ubuntu. Therefore, I went to look up [Werror], and found the bug in CMakeLists.txt:Original file:if(HAVE_CLANG_THREAD_SAFETY)  target_compile_options(leveldb    PUBLIC      -Werror -Wthread-safety)endif(HAVE_CLANG_THREAD_SAFETY)Therefore the bug couldn’t be clearer any more:  Mac uses clang to compile files, and here according to the CMakeLists, once you have clang to compile, the compiler will treat some warnings as ERROR !Once the bug was found, CMakeLists needed to be modified:if(HAVE_CLANG_THREAD_SAFETY)  target_compile_options(leveldb    PUBLIC      -Wthread-safety)endif(HAVE_CLANG_THREAD_SAFETY)## Delete -Werror, which means closing WerrorWe could see that everything went right then.  Mac has clang only, the so-called ’gcc’ or ’g++’ are actually a pointer to clang. When you install gcc through HomeBrew, you can use gcc command, which meets most programmers’ taste, but what is working is still clang!!!  That’s why every trial was a failure on Mac even though you’d installed gcc.$ gcc --versionApple clang version 13.1.6 (clang-1316.0.21.2.5)Target: arm64-apple-darwin21.5.0Thread model: posixInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin"
  },
  
  {
    "title": "Cite your source",
    "url": "/posts/cite-your-source/",
    "categories": "TechNotes, Advanced Programming",
    "tags": "cite",
    "date": "2022-09-13 22:59:30 +0800",
    





    "snippet": "  Whenever you copy code from others,  you have to cite the source !For details, please go to: MIT Code Writing Handbook.What should be provided  URL  Date of retrieval  ( If you adapted the code ) Add “Adapted from..” or “Based on..”  ( If you use open source software ) Copyright ( in your code ) + License ( in your workspace folder )Format of citing code sourcesExample 1——Qt comment format ( No copyright )/** * A utility class. * Adapted from [xxxx, source name] on [YYYYMMDD, date of retrieval] * Source: [URL] * [..., Other introduction] */class Util{    // Insert your code here...}Example 2 ( No copyright )// Adapted from [xxxx, source name]:// [URL, where you find it]// (Source: [URL, source code] retrieved in [YYYY MM DD]Example 3 ( Open source software )// Copyright (c) YYYY ........// ....// (You can just copy the copyright from git)"
  },
  
  {
    "title": "2022.9.12 Work Journal - Tasks",
    "url": "/posts/TaskList/",
    "categories": "WorkLog, Agile",
    "tags": "task list",
    "date": "2022-09-12 14:43:30 +0800",
    





    "snippet": "Brief introduction of Agile1. Debugging: Upper computer + Lower computer(1)Check the controller program (on IPC), make sure it’s working well.(2)Check the circuit is working, in case it’s aging or breaking.(3)Read the documentation of previous work.This step is mainly for getting familiar with the project and making sure previous work is running well.2. Camera and laser radar(Not done yet)This work is mainly on upper computer.These two components are mainly used to detect the traffic status (image processing)3. Start new researchSome possible titles:Control algorithmAutomatic driving…Discuss with tutor later."
  },
  
  {
    "title": "Usage of Ubuntu on PC installed Windows Before",
    "url": "/posts/Ubuntu-Installation/",
    "categories": "TechNotes, Ubuntu",
    "tags": "Ubuntu",
    "date": "2022-09-11 14:43:30 +0800",
    





    "snippet": "Some bugs you are going to encounter(Thanks for Danny Wu&#39;s image on his blog:https://www.idannywu.com//1203.html?preview=true)Here we use DELL computer to install Ubuntu 20.04.For installation:Bug: Partition and mount pointMy computer is not completely compatible with all the softwares in Ubuntu, which caused a lot of problem. One of the most serious problems is that partition should be done manually. Here I will provide you a solution.Caution 1: Choose something else when the system remind you to choose installation type.There might be some errors because of your disk’s file system, and you didn’t set up the mount point when you try to install ubuntu. Something else allows you to set up new partition table and set your mount point manually.Like this:Then create a new partition table:This will generate freespace:Creating two partitions is enough. One is for efi, one is for root directory /.Then just install, and wait for completing.For usage:Bug 1: Bluetooth usageMost of the times, when you try to start your bluetooth through GUI operation,  you may fail totally. Because there are some files missing on your computer or you need to generate by yourself manually.Step 1 Test your bluetooth status:$ hciconfighci0:	Type: Primary  Bus: USB	BD Address: xx:xx:xx:xx:xx:xx  ACL MTU: 1021:5  SCO MTU: 255:11	UP RUNNING PSCAN ISCAN 	RX bytes:5049586 acl:286 sco:0 events:717653 errors:0	TX bytes:441366701 acl:716716 sco:0 commands:562 errors:0Normally  you should see this output. However, sometimes you may find your device is down.If so, try this:$ dmesg | grep -i &#39;bluetooth&#39;[    1.637491] usb 3-8: Product: Bluetooth Radio[    1.998444] Bluetooth: Core ver x.xx[    1.998714] NET: Registered PF_BLUETOOTH protocol family[    1.998716] Bluetooth: HCI device and connection manager initialized[    1.998719] Bluetooth: HCI socket layer initialized[    1.998741] Bluetooth: L2CAP socket layer initialized[    1.998745] Bluetooth: SCO socket layer initialized[    2.047006] Bluetooth: hci0: RTL: examining hci_ver=0a hci_rev=000b lmp_ver=0a lmp_subver=8761[    2.047817] Bluetooth: hci0: RTL: rom_version status=0 version=1[    2.047820] Bluetooth: hci0: RTL: loading rtl_bt/rtl8761bu_fw.bin[    2.056603] Bluetooth: hci0: RTL: loading rtl_bt/rtl8761bu_config.bin[    2.056623] bluetooth hci0: Direct firmware load for rtl_bt/rtl8761bu_config.bin failed with error -2[    2.056632] Bluetooth: hci0: RTL: cfg_sz -2, total sz 21364[    2.195857] Bluetooth: hci0: RTL: fw version 0x0d99646b[    3.733812] Bluetooth: BNEP (Ethernet Emulation) ver 1.3[    3.733815] Bluetooth: BNEP filters: protocol multicast[    3.733819] Bluetooth: BNEP socket layer initialized[   48.211273] Bluetooth: RFCOMM TTY layer initialized[   48.211282] Bluetooth: RFCOMM socket layer initialized[   48.211285] Bluetooth: RFCOMM ver x.xx[93405.468449] bluetoothd[567]: segfault at 18 ip xxxxxxxxxxxxxxx sp xxxxxxxxxxxxxxx error 4 in bluetoothd[5598d0f72000+9b000]This command helps you to display boot info and show all the files whose name contains “bluetooth”.If you find any files missing, recover it manually. Take this binary file as an example:$ sudo cp  BCM43142A0-0a5c-21d7.hcd /lib/firmware/brcm/BCM43142A0-0a5c-21d7.hcd$ sudo modprobe -r btusb$ sudo modprobe btusbReboot your PC, and check whether it works."
  },
  
  {
    "title": "Basic usage of ROS (3)",
    "url": "/posts/Basic-Usage-of-ROS-C/",
    "categories": "TechNotes, ROS",
    "tags": "ros",
    "date": "2022-09-05 14:34:30 +0800",
    





    "snippet": "How to Complete CMakeLists.txt and package.xmlIn ROS developing, CMakelists.txt and package.xml are two important files to build a package. Only the files under your package direcotry need to be modified. Since you are not sure what dependencies you are going to use at the beginning, therefore in real developing process the CMakeLists.txt and package.xml writing can’t be done completely by catkin_create_pkg.CMakeLists.txtHere are several basic commands:            Function      Command      Usage                  Environment Configuration      cmake_minimum_required(VERSION x.x.x)      Set up the minimum version of CMake installed on your computer              Environment Configuration      project(xxx)      Package name (automatiaclly generated by ROS)              Find dependencies      find_package(XX REQUIRED xxx)      Normally catkin is necessary              Add executable targets      add_executable(EXEC FILES)      EXEC-executable file name; FILES-all compilation units (.cpp)              Add target library      add_library(LIB FILES)      LIB-library name; FILES-all compilation units (.cpp)              Link libraries      target_link_libraries(EXEC LIB)      EXEC-executable file name;LIB-library name              Include header files      target_include_directories(${PROJECT_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include)      CMAKE_CURRENT_SOURCE_DIR=PACKAGE/src      For complete tutorials, go to ROS wiki — CMakeLists.txt for further info.  Here we find that somewhere has # commented, somewhere has ## commented, somewhere has no comment.This a small trick:      No comment———This part is indispensible. You’d better not comment them or your project can’t be made.    # commented——This part is optional, you can uncomment them when you need.    ## commented—–This part is the real comment. Don’t uncomment them.  Package.xml"
  },
  
  {
    "title": "Basic usage of ROS (2)",
    "url": "/posts/Basic-Usage-of-ROS-B/",
    "categories": "TechNotes, ROS",
    "tags": "ros",
    "date": "2022-09-04 15:26:30 +0800",
    





    "snippet": "Basic Operations and Learning ResourcesPart 1 Learning Resources1. Official resourcesROS wikiROS answersROS wiki have the most comprehensive learning materials, including operations and package introduction.ROS answers is the official Q&amp;amp;A community.  VPN is unnecessary here. However, a VPN can make your visit faster and smoother, so better get one.2. Other convenient resourcesThe best solution when you can’t find answer on ROS wiki is GOOGLINGWhen you google, you may find many useful websites and blogs written by fully experienced developers, such as  CSDN, Stackoverflow and so on.  VPN is required when googling.With those resources, your learning process may become easier.Part 2 Basic Operations1. Configure your environmentTo start ROS automatically whenever you open a new terminal, run:echo &quot;source /opt/ros/noetic/setup.bash&quot; &amp;gt;&amp;gt; ~/.bashrc # Write &quot;source&quot; into bash configsource ~/.bashrc # Activate new bash configNow ROS environment can be acitivated once you open a new terminal.2. Manage ROS filesystemHere are some useful commands to navigate ROS filesystem:roscd [package][/subdir]		# Automatically go to /opt/ros/noeticrospack find [package]			# Show the path of certain packagerosls [package]These commands will save you a lot of time of inputting a long file path.3. Start your workStep 1: Create a new workspaceEach time you start your work, you need a workspace to use catkin tools.mkdir -p WORKSPACE_NAME/src	# Replace WORKSPACE_NAME with custom name of your new workspacecd WORKSPACE_NAME/src				# Go to /src in your workspaceStep 2 Create a packageROS use packages to accomplish all the functions. To create your own ROS package, run:catkin_create_pkg PKG_NAME [dependency 1][dependency 2]...# Replace PKG_NAME with custom package name# If you develop ROS project with Cpp, dependency &#39;roscpp&#39; is required at least# Else if you develop with Python, dependency &#39;rospy&#39; is required at least# You can also add other dependencies, it depends on which packages you need to include  Actually, this command mainly helps you to generate the files entailed to build your project. Therefore, if you are not sure what dependency you may need in your work, you can addroscpp/ rospy only, and add the other dependencies in CMakeLists.txt  and  package.xml later.Step 3 Build your packageGo to your package directory:cd PKG_NAMEIf you run ls , you will see:CMakeLists.txt package.xml src includeNow you can start your work like a normal Cpp or Python project. Take Cpp as example, put header files in /include, and put source files in /src,.  Remember to modify CMakeLists.txt and package.xml, how to do this will be posted in Basic Usage of ROS (3)After you finish your work, build the package:cd $PATH_OF_WORKSPACEcatkin_makecd srcIf you run ls , you will see the following:PKG_NAME CMakeLists.txtThis means building and compilation are all successful.Step 4 Test your packageUse rosrun to run your project:rosrun [package] [exec file]  There is something different from ROS 2. In ROS 1, what we need to run is executable file, instead of .cpp or .py file !HOORAY !!!!!!!! Now you can create your own work now !"
  },
  
  {
    "title": "Basic usage of ROS (1)",
    "url": "/posts/Basic-Usage-of-ROS-A/",
    "categories": "TechNotes, ROS",
    "tags": "ros",
    "date": "2022-09-03 09:07:30 +0800",
    





    "snippet": "Introduction and Installation of ROSPart 1 What is ROS?ROS (Robot Operating System) is a kind of software characteristic of operating system. Currently most developers use Ubuntu to run ROS. Actually it can be used to build a real robot, not only simulations.If you want to learn ROS by yourself, you can go to ROS wiki  for details.Part 2 Installation  In this essay, we recommend Ubuntu 20.04, because this is the latest version compatible with both ROS 1 and 2. Even though we do not use ROS 2 here,  since ROS 1 has already stopped updating, we are almost sure that ROS 2 might replace ROS 1 in the future.Step 1: Choose your ROS versionYou may look up the correspondence between ROS and Ubuntu versions in ROS wiki. For Ubuntu 20.04 we choose Noetic.Step 2: Setup your source.listAdd packages.ros.org to your ubuntu source list:sudo sh -c &#39;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &amp;gt; /etc/apt/sources.list.d/ros-latest.list&#39;Step 3: Setup your keys and check your sourceMake sure that you’ve installed curl first. No matter whether you are sure or not, just run the following command:sudo apt install curlDo not worry that you may get two curls in your Ubuntu. If you’ve installed curl before, this command will do the update check only.Then add keys:curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc # Use curl to download ros.ascsudo apt-key adv --keyserver &#39;hkp://keyserver.ubuntu.com:80&#39; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654  Don’t just copy the command from ros wiki, because the command provided didn’t provide the  pubkey, if you cmd c+v unquestioningly, you may see an error report like this when you try the next step:Now you can check your sources:sudo apt updateStep 4 Install ROSHere we recommend Desktop-full Install, because the features in this version are the most complete, and it also contains tutorial projects.sudo apt install ros-noetic-desktop-full  If you want to install more other packages ROS doesn’t have, use the following command:sudo apt install ros-noetic-PACKAGE # Replace PACKAGE with target package nameStep 5 Setup the environmentROS environment is quite like bash, use the following command to source ros-bash:source /opt/ros/noetic/setup.bashecho &quot;source /opt/ros/noetic/setup.bash&quot; &amp;gt;&amp;gt; ~/.bashrc source ~/.bashrc # Whenever you open your local bash, &#39;setup.bash&#39; will be sourced automatically# If you use zsh, replace &#39;bashrc&#39; with &#39;zshrc&#39;Step 6 Install dependenciesThe work we’ve already done before allows us to run ros core packages. To make more convenience for your work, here some useful tools that are necessary. To install them, run the following command:sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential# rosdep, rosinstall, wstool, etc.Before you use the tools, you need to initialize rosdep:sudo rosdep initrosdep update  Some times you may get an error report like this:If you encounter this problem, follow the following steps:  Ping the domain:ping raw.githubusercontent.com# &#39;raw.githubusercontent.com&#39; is mainly used to store files (except source code), we download non-code files from here.If it can’t work, please check your network status. If it works,  go to the next step.  Find ip address of the domain:  Here we recommend ipaddress.com, which is useful when looking up the ip address of one URL.As for raw.githubusercontent.com, here are several common ip addresses:      185.199.108.133    185.199.109.133    185.199.110.133    185.199.111.133The tip is just my experience, the ip may change sometimes, anyway, the core task is to find out the IP address.Add the IP address to ~/etc/hosts, save and close the file.    Retry step 1. If it doesn’t work,  you may need to complete the process of ‘rosdep init’ command manually.  In linux, everything is file. If a command cannot work, the most possible reason is file loss. Therefore, if we can recover the missing files, most of the problems can be solved.Just find another computer with ros,  compare the files and directories in /ros of the two computers, and add the file by yourself.  This is extremely unrecommended ! Because you are not sure whether other tools have the same problem. Also, keeping your network active is necessary for all work, so trying step 1 and step 2 is enough, if it can’t work, I highly suggest you to change a computer…HOORAY !!!!!!!! You&#39;ve already finished all the steps, and now you can explore ROS as you wish !"
  }
  
]

